# 案例分析 #

## 1、主要功能 #

查询: 输入(出发地、目的地、出发日)，返回(车次、过站、时间、价格、每种座位的余票数量)

订票: 输入订单信息，判断是否可以出票，如是则分配座位号并出票，订单状态=待支付

支付: 输入聚合支付信息，修改订单状态=已支付

退票: 输入订单信息，退款、回收座位、注销车票、修改订单状态=已退款

中转: 如果经查询没有直达车次，在铁路有向图寻找最短路径(按价格、时间排序)，返回车次

改签: 输入(订单信息、更新信息)，判断允许改签，更新订单信息、可用票数，计算差价，订单支付状态=0，更新支付信息: 是否更新(1)，更新状态(待退款/待补差价)

候补购票: 无票时可以候补排队，余票自动购买，有截止日期，可取消

## 2、数据实体关系图 #

## 3、数据库逻辑图 #

## 4、存在的问题 #

* 没有性能优化
* 未涉及并发处理
* 未涉及容灾备份
* 查询中转时未区分车站等级、铁路局、客运段
* 资金处理过于简单

## 5、改进方法 #

* 分布式集群部署
* 容灾手段(双火机房、节点容错、服务器灾备等)
以上，由阿里云提供技术支持

* 加入车站等级、铁路局、客运段，加快中转查询速度
* 更新聚合支付功能

## 6、数据处理过程 #

```py
车票信息 = 查询余票(出发地、目的地、出发日){
    车票信息 = 车次，过站，时间，价格，每种座位的余票数量。
}

(车票信息、订单信息) = 订票(订单信息){
    if !允许购票(订单信息)
        拒绝订票
    查询余票;
    选择可用的座位;
    车票信息 = 车次，时间，价格，座位号、席位类别、
    支付状态=0;
    根据优惠状态确定价格
    订单状态=待支付
    更新一次出票时所有原子区间的可用票数，用于判断下次是否能出票;
    维护所有已售出的票，用于为选择可用座位提供依据;
}

(车票信息、订单信息) = 支付(订单信息、支付信息){
    验证交易成功
    支付状态=1
    订单状态=完成
}

中转车票信息 = 查询中转((出发地、目的地、出发日){
    铁路有向图寻找最短路径(价格排序)
    铁路有向图寻找最短路径(时间排序)
}

(车票信息、订单信息) = 退票(订单号){
    车票信息注销
    订单状态=退票
    返还金额
    更新可用票数
    查询候补
}

订单信息 = 改签(订单信息、更新信息){
    判断允许改签
    更换订单信息
    更新可用票数
    查询候补

    计算差价
    支付状态=0
    更新支付信息: 是否更新(1)，更新状态(待退款/待补差价)
}

(候补购票信息) = 候补购票(购票人、下单时间、车票信息、截止时间){
    if !允许购票
        拒绝订票
    支付状态=0;
    根据优惠状态确定价格
    订单状态=待支付
    查询已有候补、确定排位
}

(候补购票信息) = 取消候补购票(候补购票信息){
    订单状态=取消候补购票
    退款
    更新候补排位
}

候补检查: 每日检查到期候补订单，取消之并退款，更新其余候补排位

某种座位的余票数量 = 余票数量(车次、席位类别、出发地、目的地、出发日){
    遍历(各区间): 
        x(i) = 座位数据(车次、席位类别、出发日).(出票限制-各区间占用情况)*1(在允许发售时间)
    某种座位的余票数量 = min(x)
}

0/1 = 允许购票(订单信息){
    乘车人不超过5个
    乘车人不被限制乘车
    乘车人没有同时间段其他车票
}
```
